var documenterSearchIndex = {"docs":
[{"location":"api.html#API-reference-1","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"CurrentModule = HEAAN","category":"page"},{"location":"api.html#Scheme-parameters-1","page":"API reference","title":"Scheme parameters","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"Params","category":"page"},{"location":"api.html#HEAAN.Params","page":"API reference","title":"HEAAN.Params","text":"Params(; log_polynomial_length::Int=16, log_lo_modulus::Int=300)\n\nHEAAN scheme parameters.\n\nlog_polynomial_length determines the length of polynomials used for keys and ciphertexts; larger length is more secure, but also slower.\n\nlog_lo_modulus determines the maximum computation resource that a ciphertext can have. Larger values are more secure and allow for longer computation sequences without bootstrapping; but, again, are slower and make ciphertexts take more place in memory.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Keys-1","page":"API reference","title":"Keys","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"SecretKey\nEncryptionKey\nMultiplicationKey\nLeftRotationKey\nConjugationKey","category":"page"},{"location":"api.html#HEAAN.SecretKey","page":"API reference","title":"HEAAN.SecretKey","text":"SecretKey(rng::AbstractRNG, params::Params)\n\nSecret key, used for decryption. Takes a Params object.\n\n\n\n\n\n","category":"type"},{"location":"api.html#HEAAN.EncryptionKey","page":"API reference","title":"HEAAN.EncryptionKey","text":"EncryptionKey(rng::AbstractRNG, secret_key::SecretKey)\n\nA public key used for encryption. Needs a SecretKey object.\n\n\n\n\n\n","category":"type"},{"location":"api.html#HEAAN.MultiplicationKey","page":"API reference","title":"HEAAN.MultiplicationKey","text":"MultiplicationKey(rng::AbstractRNG, secret_key::SecretKey)\n\nA public key used for multiplication of two ciphertexts. Needs a SecretKey object.\n\n\n\n\n\n","category":"type"},{"location":"api.html#HEAAN.LeftRotationKey","page":"API reference","title":"HEAAN.LeftRotationKey","text":"LeftRotationKey(rng::AbstractRNG, secret_key::SecretKey, shift::Int)\n\nA public key used for left rotation (circshift() with a negative argument) of a ciphertext. Needs a SecretKey object and the absolute value of the shift (a separate key is needed for each value of the shift).\n\n\n\n\n\n","category":"type"},{"location":"api.html#HEAAN.ConjugationKey","page":"API reference","title":"HEAAN.ConjugationKey","text":"LeftRotationKey(rng::AbstractRNG, secret_key::SecretKey)\n\nA public key used for conjugation of a ciphertext. Needs a SecretKey object.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Encryption/decryption-1","page":"API reference","title":"Encryption/decryption","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"Ciphertext\nencrypt\ndecrypt","category":"page"},{"location":"api.html#HEAAN.Ciphertext","page":"API reference","title":"HEAAN.Ciphertext","text":"A ciphertext object created by encrypt.\n\n\n\n\n\n","category":"type"},{"location":"api.html#HEAAN.encrypt","page":"API reference","title":"HEAAN.encrypt","text":"encrypt(\n    rng::AbstractRNG, key::EncryptionKey, vals::Array{Complex{Float64}, 1},\n    log_precision::Int, log_cap::Int)\n\nCreates a Ciphertext object out of a complex-valued array vals.\n\nlog_precision determines the (absolute) precision used for encoding (cannot be larger than log_cap).\n\nlog_cap is the available computation resource (cannot be larger than Params.log_lo_modulus; see explanation thereof).\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.decrypt","page":"API reference","title":"HEAAN.decrypt","text":"decrypt(secret_key::SecretKey, cipher::Ciphertext)\n\nDecrypts a Ciphertext object and returns the resulting complex-valued array.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Arithmetic-operations-1","page":"API reference","title":"Arithmetic operations","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"add\nadd_const\nsub\nmul\nsquare\nnegate\nimul\nmul_by_const\nmul_by_const_vec\ndiv_by_po2\ncircshift\nconj\ninv\npower\npower_series\nsigmoid\nlog_plus_one\nexp","category":"page"},{"location":"api.html#HEAAN.add","page":"API reference","title":"HEAAN.add","text":"add(cipher1::Ciphertext, cipher2::Ciphertext)\n\nElementwise addition of encrypted vectors. Both ciphertexts must have the same log_cap and log_precision.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.add_const","page":"API reference","title":"HEAAN.add_const","text":"add_const(cipher::Ciphertext, cnst::Float64)\n\nAdds a floating-point number cnst to each element of an encrypted vector. Ciphertext's log_precision is used to encode cnst.\n\n\n\n\n\nadd_const(cipher::Ciphertext, cnst::Float64)\n\nAdds a complex number cnst to each element of an encrypted vector. Ciphertext's log_precision is used to encode cnst.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.sub","page":"API reference","title":"HEAAN.sub","text":"sub(cipher1::Ciphertext, cipher2::Ciphertext)\n\nElementwise subtraction of encrypted vectors. Both ciphertexts must have the same log_cap and log_precision.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.mul","page":"API reference","title":"HEAAN.mul","text":"mul(key::MultiplicationKey, cipher1::Ciphertext, cipher2::Ciphertext)\n\nElementwise multiplication of encrypted vectors. Needs a MultiplicationKey. Both ciphertexts must have the same log_cap (but can have different log_precision); log_precision of the result is the sum of log_precision of both ciphertexts.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.square","page":"API reference","title":"HEAAN.square","text":"square(mk::MultiplicationKey, cipher::Ciphertext)\n\nElementwise square of an encrypted vector. Needs a MultiplicationKey object. log_precision of the result is doubled.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.negate","page":"API reference","title":"HEAAN.negate","text":"negate(cipher::Ciphertext)\n\nElementwise negation of an encrypted vector.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.imul","page":"API reference","title":"HEAAN.imul","text":"imul(cipher::Ciphertext)\n\nMultiplies each element of an encrypted vector by the imaginary unit.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.mul_by_const","page":"API reference","title":"HEAAN.mul_by_const","text":"mul_by_const(cipher::Ciphertext, cnst::Float64, log_precision::Int)\n\nMultiplies each element of an encrypted vector by a floating-point number cnst. The provided log_precision is used to encode cnst.\n\n\n\n\n\nmul_by_const(cipher::Ciphertext, cnst::Complex{Float64}, log_precision::Int)\n\nMultiplies each element of an encrypted vector by a complex number cnst. The provided log_precision is used to encode cnst.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.mul_by_const_vec","page":"API reference","title":"HEAAN.mul_by_const_vec","text":"mul_by_const_vec(cipher::Ciphertext, v::Array{Complex{Float64}, 1}, log_precision::Int)\n\nMultiplies each element of an encrypted vector by the corresponding element of v. log_precision is used to encode elements of v.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.div_by_po2","page":"API reference","title":"HEAAN.div_by_po2","text":"div_by_po2(cipher::Ciphertext, bits::Int)\n\nElementwise division of an encrypted vector by 2^bits.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.circshift","page":"API reference","title":"Base.circshift","text":"circshift(rk::LeftRotationKey, cipher::Ciphertext, shift::Integer)\n\nRotates an encrypted vector (currently only to the left, that is shift must be negative). The LeftRotationKey must correspond to shift.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.conj","page":"API reference","title":"Base.conj","text":"conj(ck::ConjugationKey, cipher::Ciphertext)\n\nConjugates an encrypted vector. Needs a ConjugationKey object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.inv","page":"API reference","title":"Base.inv","text":"inv(mk::MultiplicationKey, cipher::Ciphertext, log_precision::Int, steps::Int)\n\nCalculates an inverse (1/x) of each element of an encrypted vector, using a steps-power approximation. log_precision determines the step used to rescale the intermediate values. Needs a MultiplicationKey object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.power","page":"API reference","title":"HEAAN.power","text":"power(mk::MultiplicationKey, cipher::Ciphertext, log_precision::Int, pwr::Int)\n\nRaises each element of an encrypted vector to the (non-negative) power pwr. log_precision determines the step used to rescale the intermediate values. Needs a MultiplicationKey object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.power_series","page":"API reference","title":"HEAAN.power_series","text":"power_series(\n    mk::MultiplicationKey, cipher::Ciphertext, log_precision::Int,\n    coeffs::Array{Float64, 1}; lazy::Bool=false)\n\nCalculates a power series (a + bx + cx^2 + ...) for each element x of an encrypted vector, with coefficients coeffs. log_precision is used to rescale the intermediate values. Needs a MultiplicationKey object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.sigmoid","page":"API reference","title":"HEAAN.sigmoid","text":"sigmoid(mk::MultiplicationKey, cipher::Ciphertext, log_precision::Int, max_pwr::Int)\n\nCalculates the sigmoid function exp(x) / exp(1+x) for each element of an encrypted vector, using a max_pwr-power approximation. log_precision determines the step used to rescale the intermediate values. Needs a MultiplicationKey object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.log_plus_one","page":"API reference","title":"HEAAN.log_plus_one","text":"log_plus_one(mk::MultiplicationKey, cipher::Ciphertext, log_precision::Int, max_pwr::Int)\n\nCalculates log(1 + x) for each element of an encrypted vector, using a max_pwr-power approximation. log_precision determines the step used to rescale the intermediate values. Needs a MultiplicationKey object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Base.exp","page":"API reference","title":"Base.exp","text":"exp(mk::MultiplicationKey, cipher::Ciphertext, log_precision::Int, max_pwr::Int)\n\nCalculates exp(x) for each element of an encrypted vector, using a max_pwr-power approximation. log_precision determines the step used to rescale the intermediate values. Needs a MultiplicationKey object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Computation-resource-management-1","page":"API reference","title":"Computation resource management","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"mod_down_by\nmod_down_to\nrescale_by\nBootstrapKey\nbootstrap","category":"page"},{"location":"api.html#HEAAN.mod_down_by","page":"API reference","title":"HEAAN.mod_down_by","text":"mod_down_by(cipher::Ciphertext, dlog_cap::Int)\n\nDecreases log_cap of a Ciphertext object by dlog_cap.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.mod_down_to","page":"API reference","title":"HEAAN.mod_down_to","text":"mod_down_to(cipher::Ciphertext, log_cap::Int)\n\nDecreases log_cap of a Ciphertext object to the provided value.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.rescale_by","page":"API reference","title":"HEAAN.rescale_by","text":"rescale_by(cipher::Ciphertext, dlog_cap::Int)\n\nDecreases log_cap and log_precision of a Ciphertext object by dlog_cap.\n\n\n\n\n\n","category":"function"},{"location":"api.html#HEAAN.BootstrapKey","page":"API reference","title":"HEAAN.BootstrapKey","text":"BootstrapKey(\n    rng::AbstractRNG, secret_key::SecretKey,\n    enc_key::EncryptionKey, mul_key::MultiplicationKey, conj_key::ConjugationKey,\n    log_slots::Int, log_precision::Int)\n\nA public key used for bootstrapping. Can only be applied to encrypted vector of size 2^log_slots. Needs the SecretKey, an EncryptionKey, a MultiplicationKey and a ConjugationKey.\n\n\n\n\n\n","category":"type"},{"location":"api.html#HEAAN.bootstrap","page":"API reference","title":"HEAAN.bootstrap","text":"bootstrap(bk::BootstrapKey, cipher::Ciphertext, log_t::Int=4)\n\nBootstrap a ciphertext, increasing the difference between its log_cap and log_precision. Needs a BootstrapKey object.\n\n\n\n\n\n","category":"function"},{"location":"history.html#Version-history-1","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history.html#v0.1.0-1","page":"Version history","title":"v0.1.0","text":"","category":"section"},{"location":"history.html#","page":"Version history","title":"Version history","text":"Initial version.","category":"page"},{"location":"manual.html#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual.html#A-simple-example-1","page":"Manual","title":"A simple example","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The following example illustrates basics of working with the library. For more examples see examples/basic.jl and test/api.test.jl in the repository.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"First, we import the required libraries and initialize constants:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"using Random\nusing HEAAN\n\n# Polynomial length and full modulus determine the security of the scheme\nparams = Params(log_polynomial_length=8, log_lo_modulus=300)\n\n# Vector size\n# The maximum vector size is polynomial_length / 2\nn = 2^6\n\n# Initial precision for ciphertexts (that is, the absolute precision is 1/2^30)\nlog_precision = 30\n\n# Initial precision cap for ciphertexts\n# Gets consumed during e.g. multiplication\nlog_cap = 200\n\nrng = MersenneTwister(123)","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Then we need to create keys. A secret key is required to decrypt ciphertexts and initialize public keys. There are several different public keys in HEAAN; in this example we will only use two: the one required for encryption, and the one required for multiplication. Addition of ciphertexts can be performed without a key.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"secret_key = SecretKey(rng, params)\n\n# Public key used for encryption\nenc_key = EncryptionKey(rng, secret_key)\n\n# Public key used for multiplication\nmul_key = MultiplicationKey(rng, secret_key)","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"We create two complex-valued vectors of length n and initialize the reference array.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"v1 = rand(rng, n) + im * rand(rng, n)\nv2 = rand(rng, n) + im * rand(rng, n)\n\n# Reference calculation\nref = x .* y .+ x","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Use enc_key to create initial ciphertexts. log_precision specifies the absolute precision for encrypted values; log_cap is essentially the \"resource\" that gets spent during arithmetic operations on ciphertexts. Naturally, log_cap should be greater than log_precision.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"# Encrypt the initial vectors\nc1 = encrypt(rng, enc_key, v1, log_precision, log_cap)\nc2 = encrypt(rng, enc_key, v2, log_precision, log_cap)\n\nprintln(\"Before: precision=$(c1.log_precision), cap=$(c1.log_cap)\")\n\n# output\nBefore: precision=30, cap=200","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"We start from performing the (elementwise) multiplication.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"t1 = mul(mul_key, c1, c2)\n\nprintln(\"After multiplication: precision=$(t1.log_precision), cap=$(t1.log_cap)\")\n\n# output\nAfter multiplication: precision=60, cap=200","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Note that the precision of the result is the sum of the precisions of ciphertexts, while the cap remained the same. This means that you cannot just multiply indefinitely –- after several iterations you will lose the encrypted information. This problem is solved by bootstrap() which increases the difference between precision and log_cap, essentially adding the \"computation resource\".","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Another consequence of this is that now t1 and c1 which we want to add together have different log_cap. In order to add() them, both their log_cap and log_precision must be equal. There are two functions that help with that: rescale_by() and mod_down_by(). The former decreases both log_cap and log_precision by the same amount; the latter just decreases log_cap. As it happens, in our case we need both of them.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"t2 = rescale_by(t1, 30)\n\nprintln(\"After rescale: precision=$(t2.log_precision), cap=$(t2.log_cap)\")\n\nt3 = mod_down_by(c1, 30)\n\nprintln(\"After mod_down: precision=$(t3.log_precision), cap=$(t3.log_cap)\")\n\n# output\nAfter rescale: precision=30, cap=170\nAfter mod_down: precision=30, cap=170","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Now that the parameters are equalized, we can call add() and decrypt the result.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"cres = add(t2, t3)\n\nres = decrypt(secret_key, cres)\nref = reference(v1, v2)\n\nfor i in 1:n\n    println(\"$i-th element: diff=$(abs(res[i] - ref[i]))\")\nend\n\n# output\n1-th element: diff=1.8071040828704262e-8\n2-th element: diff=4.8677934407457675e-8\n3-th element: diff=3.612811639903806e-8\n4-th element: diff=2.9650269405023588e-8\n...","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"As you can see, the calculation is accurate to about 25 bits.","category":"page"},{"location":"index.html#A-Julia-implementation-of-the-HEAAN-scheme-1","page":"Home","title":"A Julia implementation of the HEAAN scheme","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"This is an implementation of:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"J. H. Cheon, A. Kim, M. Kim, and Y. Song, \"Homomorphic Encryption for Arithmetic of Approximate Numbers,\" Lecture Notes in Computer Science, Vol. 10624 LNCS, pp. 409–437 (2017),","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"and partially","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"J. H. Cheon, K. Han, A. Kim, M. Kim, and Y. Song, \"Improved Bootstrapping for Approximate Homomorphic Encryption,\" eprint 2018/1043.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"For the further development of this scheme one can refer to","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"J. H. Cheon, K. Han, A. Kim, M. Kim, and Y. Song, \"A Full RNS Variant of Approximate Homomorphic Encryption,\" eprint 2018/931.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The implementation is based on the reference C++ code.","category":"page"}]
}
